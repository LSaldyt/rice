{"version":3,"sources":["webpack:///webpack/bootstrap 072a31b12465057f48cd","webpack:///./src/client/interceptedEventTypes.js","webpack:///./src/lib/dom.js","webpack:///./src/content_script/eventListeners.js","webpack:///./node_modules/mosi/light-client.js","webpack:///./src/content_script/loader.js"],"names":[],"mappings":"YACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,KAIA,2CAGA,aAGA,OACA,OAIA,IAzBA,eA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,wDCvDA,OACE,CACA,WACA,YACA,SACA,QACA,SACA,SACA,cAAoB,uCCiBQ,aAC5B,IAAI,EAAQ,UAAY,EAAQ,SAChC,gBAAQ,EACN,MACA,gBACA,WACA,aACA,YACA,UACA,aACA,eACA,WACE,MAEJ,UACD,QAED,CAMgB,WAAmB,EAAO,SACxC,MAAM,GAAgB,EACtB,cAAM,EAA0B,GAAiB,EACjD,iBAAO,GAGR,MAED,KArDgC,WAC9B,CAAI,KACF,QAAQ,EACN,cACE,cACF,UACA,eACE,SAEJ,UACE,eACA,MADK,KAAQ,gBAAgB,kBAE3B,aADG,KAAQ,KAGhB,UACD,CACD,QAED,YA0CqC,aAAqB,KACxD,IAEE,GACE,YAEF,yCACE,cAEF,wCACE,YAGJ,uDAAO,QAAQ,KACb,MAAM,GAAQ,GAAe,gBAC3B,CACA,WACA,mBACA,cAGF,SACD,gBACF,EAED,MAcoC,WAG9B,cAIL,oBAuBD,MAIsB,WACpB,MAAM,GAAW,SAAS,cAC1B,cAAS,MACT,2BACA,iBAAS,KACT,iBACA,kBAAS,YACT,iBAAS,KACV,cAED,MAMgB,UACd,MAAM,GAAW,SAAS,cAC1B,cAAS,MACT,kCAAS,KACT,iBACA,iBAAS,YACT,cAAM,GAAQ,EACd,MAED,gBAFU,KACT,gBAGF,MAC4C,mBAC1C,MAAM,GAAM,IAAI,gBACd,GAAI,MAAK,CAAC,KAAe,YAAQ,KAAM,IACrC,MAGJ,8CAAM,SAAQ,UAAU,SACtB,CACA,MACA,WAEH,W,qKArLD,EAiGO,KACL,GAE0D,yBAC5D,uCCpF0B,aACxB,QACD,wDCPD,mBDGA,IEDwB,CAApB,QAAO,YACT,CAD2B,QAAO,cFOpB,UACd,QAAO,eAAiB,IAAQ,CAChC,SAAO,KAAK,KAAuB,QAAoB,KACrD,QACD,wBACD,UAAO,gCAAkC,IACvC,QAAO,eAAiB,IAAQ,CAChC,SAAO,KAAK,KAAuB,QAAQ,KACzC,QACD,2BAEF,KAEF,IEpBD,CAEE,aDHF,IACA,kBAEA,gEACA,aACA,EACA,MACA,SAEA,UCNM,EACL","file":"content_script_loader.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 38);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 072a31b12465057f48cd","import { fullscreenchange } from 'lib/dom'\n\n/**\n * Events Saka Key intercepts and whether they must be trusted or not.\n * Keyboard events must be trusted so that websites cannot issue arbitrary commands\n */\nexport default {\n  keydown: true,\n  keypress: true,\n  keyup: true,\n  blur: false,\n  focus: false,\n  click: false,\n  mousedown: false,\n  [fullscreenchange]: false\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/interceptedEventTypes.js","/**\n * Given a DOM element, returns true if you can edit it with key presses or\n * if the element is of a type that should handle its own keypresses\n * (e.g. role=application for google docs/sheets)\n * TODO: work on case sensitivity\n * consider all the possible cases\n * @param {HTMLElement} element\n * @returns {boolean}\n */\nexport function isTextEditable (element) {\n  if (element) {\n    switch (element.nodeName) {\n      case 'INPUT':\n        return isEditableHTMLInput(element)\n      case 'TEXTAREA':\n      case 'OBJECT':\n        return true\n    }\n    switch (true) {\n      case element.contentEditable.toUpperCase() === 'TRUE':\n      case element.role === 'application':\n        return true\n    }\n  }\n  return false\n}\n\n/**\n * Returns whether the passed HTML input element is editable\n * @param {HTMLInputElement} element\n */\nfunction isEditableHTMLInput (element) {\n  if (element.disabled || element.readonly) return false\n  switch (element.type) {\n    case undefined:\n    case 'text':\n    case 'search':\n    case 'email':\n    case 'url':\n    case 'number':\n    case 'password':\n    case 'date':\n    case 'tel':\n      return true\n  }\n  return false\n}\n\n/**\n * Like document.activeElement, but penetrates through Shadow DOM\n * A good example is: https://web.archive.org/web/20170621214451/https://material.io/icons/\n * Click on the input. document.activeElement is different from deepActiveElement()\n * @param {HTMLElement} root\n */\nexport function deepActiveElement (root = document) {\n  const activeElement = root.activeElement\n  const activeElementShadowRoot = activeElement && activeElement.shadowRoot\n  return activeElementShadowRoot\n    ? deepActiveElement(activeElementShadowRoot)\n    : activeElement\n}\n\n/**\n * Dispatch a mouse event to the target element\n * based on cVim's implementation\n * @param {HTMLElement} element\n * @param {'hover' | 'unhover' | 'click'} type\n * @param {{ ctrlKey, shiftKey, altKey, metaKey }} modifierKeys\n */\nexport function mouseEvent (element, type, modifierKeys = {}) {\n  let events\n  switch (type) {\n    case 'hover':\n      events = ['mouseover', 'mouseenter', 'mousemove']\n      break\n    case 'unhover':\n      events = ['mousemove', 'mouseout', 'mouseleave']\n      break\n    case 'click':\n      events = ['mouseover', 'mousedown', 'mouseup', 'click']\n      break\n  }\n  events.forEach(type => {\n    const event = new MouseEvent(type, {\n      bubbles: true,\n      cancelable: true,\n      view: window,\n      detail: 1, // usually the click count\n      ...modifierKeys\n    })\n    element.dispatchEvent(event)\n  })\n}\n\n/**\n * TODO: use standard fullscreenchange event when browsers support it\n */\nexport const fullscreenchange =\n  SAKA_PLATFORM === 'chrome'\n    ? 'webkitfullscreenchange'\n    : SAKA_PLATFORM === 'firefox' ? 'mozfullscreenchange' : 'fullscreenchange'\n/**\n * Given a DOM event type that is vendor pre-fixed, e.g. 'mozfullscreenchange',\n * converts it to a standardized event type, e.g. 'fullscreenchange'\n * TODO: remove this if no vendor-prefixed events are needed\n * @param {string} event\n * @returns {string}\n */\nexport function normalizeEventType (type) {\n  switch (type) {\n    case fullscreenchange:\n      return 'fullscreenchange'\n    default:\n      return type\n  }\n}\n\n// TODO: figure out why elements within shadow roots aren't registered as\n// visible/clickable, then start using this method\n/**\n * Given an HTML Element, returns a list of all elements within\n * penetrating the shadow DOM\n * @param {HTMLElement} root\n */\nexport function getAllElementsIncludingShadowDOM (root = document) {\n  const allElements = root.querySelectorAll('*')\n  let shadowDescendents = []\n  allElements.forEach(element => {\n    if (element.shadowRoot) {\n      shadowDescendents = [\n        ...shadowDescendents,\n        ...getAllElementsIncludingShadowDOM(element.shadowRoot)\n      ]\n    }\n  })\n  return [...allElements, shadowDescendents]\n}\n\n/**\n * Copies the specified text to the clipboard\n * @param {string} text\n */\nexport function copy (text) {\n  const textArea = document.createElement('textarea')\n  textArea.style = 'position:fixed;right:0'\n  textArea.value = text\n  document.body.appendChild(textArea)\n  textArea.select()\n  document.execCommand('Copy')\n  document.body.removeChild(textArea)\n}\n\n/**\n * Returns the clipboard contents.\n * This method is only callable from the background page and requires\n * the \"clipboardRead\" permission to be declared in manifest.json\n * @returns {string}\n */\nexport function paste () {\n  const textArea = document.createElement('textarea')\n  textArea.style = 'position:fixed;right:0'\n  document.body.appendChild(textArea)\n  textArea.focus()\n  document.execCommand('Paste')\n  const value = textArea.value\n  document.body.removeChild(textArea)\n  return value\n}\n\n/** Saves the given object to a human-readable JSON file */\nexport async function downloadJSON (object, filename) {\n  const url = URL.createObjectURL(\n    new Blob([JSON.stringify(object, null, 2)], {\n      type: 'data:application/json;charset=utf-8'\n    })\n  )\n  await browser.downloads.download({\n    url,\n    filename,\n    saveAs: true\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/dom.js","// Saka Key installs exactly one listener for each event type of interest.\n//\n// These listeners must be installed as soon as possible, otherwise the\n// page may intercept and respond to events before Saka Key can.\n//\n// To accomplish this, the _loader script_ installs listeners that call\n// window.handleDOMEvent. When the _full client_ loads, it then defines\n// window.handleDOMEvent\n//\n// When an extension updates, Chrome cuts off content scripts from the\n// rest of the extension. This breaks messaging, so commands that rely on\n// messaging will silently stop working. To work around this, the client\n// detects when messaging is cut off and removes its event listeners. The\n// background page then loads in new clients that can handle events without\n// interference from old event listeners.\nimport interceptedEventTypes from 'client/interceptedEventTypes'\n\nfunction _handleDOMEvent (event) {\n  window.handleDOMEvent(event)\n}\n\nexport function addPreloadedEventListeners () {\n  window.handleDOMEvent = () => {}\n  Object.keys(interceptedEventTypes).forEach((eventType, i) => {\n    window.addEventListener(eventType, _handleDOMEvent, true)\n  })\n  window.removePreloadedDOMEventListener = () => {\n    window.handleDOMEvent = () => {}\n    Object.keys(interceptedEventTypes).forEach(eventType => {\n      window.removeEventListener(eventType, _handleDOMEvent, true)\n    })\n    if (SAKA_DEBUG) console.log('Preloaded Event Listeners Removed')\n  }\n  if (SAKA_DEBUG) console.log('Preloaded Event Listeners Added')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/content_script/eventListeners.js","/**\n * A lightweight, limited, msg implementation. Light-clients don't support\n * response handling thus the loop back destination (0) is invalid.\n *\n * This function is useful for avoiding code bloat loading the full mosi client\n * into frames that only need to send a simple one-off message for setup.\n *\n * Saka Key (https://github.com/lusakasa/sakakey) loads a small setup script\n * into each frame, and if the frame is determined to be valid, uses this\n * to send a message to the background page, which loads the full Saka Key\n * content script using chrome.tabs.executeScript.\n */\nexport const msg = (dst, action, arg) => {\n  if (dst === 0) {\n    throw Error('light-client msg self unsupported');\n  }\n  chrome.runtime.sendMessage({\n    mosi_lw_msg: 1,\n    dst,\n    action,\n    arg\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/mosi/light-client.js\n// module id = null\n// module chunks = ","/**\n * On Firefox, this script is unused and the full client is loaded into every frame.\n * On Chrome, this script is loaded into every frame of every page.\n * \n * The full Saka Key client (at ./index.js) is loaded only into frames\n * that the user can actually interact with to improve performance\n * \n * DOM event listeners must be installed AS SOON AS POSSIBLE otherwise\n * webpages may install listeners that react to keyboard events before Saka Key\n */\n\nimport { msg } from 'mosi/light-client'\nimport { addPreloadedEventListeners } from 'content_script/eventListeners'\n\nif (window.innerWidth > 5 && window.innerHeight > 5) {\n  addPreloadedEventListeners()\n  msg(1, 'loadClient')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/content_script/loader.js"],"sourceRoot":""}